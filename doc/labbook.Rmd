---
title: "LabBook"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: myStyle.css
    highlight: haddock
    toc: true
    toc_float: true
    number_sections: false
    code_folding: show
    df_print: paged
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  message = FALSE, # prevents messages that are generated by code from appearing in the finished file
  warning = FALSE, # prevents warnings that are generated by code from appearing in the finished
  error = TRUE, # if FALSE, knitr will not display any error messages generated by the code
  eval = TRUE, # if FALSE, knitr will not run the code in the code chunk
  include = TRUE, # f FALSE, knitr will run the chunk but not include the chunk in the final document
  results = 'hide', # If 'hide', knitr will not display the code's results in the final document. If 'hold', knitr will delay displaying all output pieces until the end of the chunk. If 'asis', knitr will pass through results without reformatting them (useful if results return raw HTML, etc.)
  fig.show = 'asis', # If 'hide', knitr will generate the plots created in the chunk, but not include them in the final document. If 'hold', knitr will delay displaying the plots created by the chunk until the end of the chunk. 
  fig.keep = 'last',
  fig.align = 'center',
  fig.width = 4.5,
  fig.height = 3,
  max.print = 3, # max no. of lines in data frames
  strip.white = TRUE, # remove leading and lagging white lines
  comment = NA # to remove all hashes
  )  
```

# Preliminaries

IGN:

http://centrodedescargas.cnig.es/CentroDescargas/catalogo.do?Serie=LIDAR
http://www.ign.es/wcts-app/
https://www.ign.es/iberpix2/visor/


Tutorials:

https://wcmbishop.github.io/rayshader-demo/


```{r}
# devtools::install_github('tylermorganwall/rayshader')
pacman::p_load(rayshader)
pacman::p_load(rgdal)
pacman::p_load(proj4)
pacman::p_load(raster)
pacman::p_load(geoviz)
pacman::p_load(shiny)
pacman::p_load(leaflet)
pacman::p_load(geosphere)


sapply(list.files(here::here('R')), function(x) source(here::here('R', x)))

# Gijón
boundingBox <- DefineBoundingBox(p1 = c(lon = -5.75, lat = 43.45), p2 = c(lon = -5.55, lat = 43.6))
```

# Plot track

## Load track

```{r, results='asis'}
trackTable <- read.csv(here::here('data', 'Oso.csv')) %>% 
  dplyr::select(1:5) %>% 
  dplyr::mutate(time = as.POSIXct(time, format = '%Y-%m-%dT%H:%M:%S')) %>% 
  dplyr::select(lon, lat)

trackTable %>%head(5) %>% knitr::kable()
```

## Define box from track

The track is intoduced by means of the variable `pointTable`. Then `DefineBoundingBox` searches for the bounding box capable of containing the track inside. If instead `boundingBox` is not null (and `pointTable` is), it can be modified using the `zoomLevel`. Another option is to introduce the points `p1` (lower left corner) and `p2` (top right corner). The points must be in format `p1 = c(lon = -5.0, lat = 41.2)` or `p1 = (x = 42000, y = 12000)`. The logical variable `is.lonLat` indicates whether the table and points introduced are in lonlat or in metric xy format. Finally, `zoomLevel > 1` enlarges the bounding box.

```{r, results='asis'}
boundingBox <- DefineBoundingBox(pointTable = trackTable, 
                                 boundingBox = NULL, 
                                 p1 = NULL, 
                                 p2 = NULL, 
                                 is.lonLat = T,
                                 zoomLevel = 1.1
)

str(boundingBox)
```

# Plot OMS wrt a bounding box

http://archived.mhermans.net/hiking-gpx-r-leaflet.html

```{r}
ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackTable)
```

## Get tiles from IGN

Regarding `ImportIGNTiles`:

- `tileResolution`: 5 (higher) or 25 (lower) resolution files.

- `folderName`: by default, the folder is `\\pocpaco\maps\`.

```{r, results='asis'}
# Obtain tile codes
tileSet <- FindIGNTiles(boundingBox = boundingBox)

print(tileSet)

# Import data into raster objects
rasterObject <- ImportIGNTiles(tileSet, 
                               tileResolution = 5,
                               folderName = here::here('data')
)
```

## Get track elevation

```{r, results='asis'}
trackTable$elevation <- extract(rasterObject, TransformCoordinates(trackTable, is.lonLat = T))

trackTable %>%head(5) %>% knitr::kable()
```

## Crop the IGN tile

Retain only the tile inside the bounding box.

```{r}
# Crop
rasterObject <- CropRaster(rasterObject, boundingBox)
```

## Extract data from raster

This extracts the elevation matrix, the extent, and the bounding box.

```{r}
mapData <- ExtractFromRaster(rasterObject)

str(mapData)
```

## Get overlay image

Map types are:

- Topo: `'World_Topo_Map'`, `NatGeo_World_Map`, `'esri-topo'`

- Relief: `'apple-iphoto'`, `'World_Street_Map'`, `Ocean_Basemap`

- Picture: `'World_Imagery'`, `'bing'`, `'maptoolkit-topo'`

- Names: `'osm'`, `'opencyclemap'`, `'landscape'`



```{r}
overlayImage <- GetMapImage(boundingBox,
                            mapType = 'osm',
                            imageWidth = dim(mapData$elevation)[1],
                            imageHeight = round(dim(mapData$elevation)[2]),
                            imageFileName = here::here('figs', 'overlay.png')
)


grid::grid.raster(overlayImage)

```

## Plot 2-D map

```{r}
# Apply 2D overlay
mapData$elevation %>%
  sphere_shade(sunangle = 270,
               texture = 'imhof4'
  ) %>%
  # add_water(detect_water(mapData$elevation, min_area = 500), color = 'imhof3') %>%
  # add_overlay(overlayImage, alphalayer = 0.9) %>%
  plot_map()
```

## Plot 3-D map

```{r}
# Apply 3D overlay
mapData$elevation %>%
  sphere_shade(texture = 'imhof4', sunangle = 120) %>%
  add_water(detect_water(mapData$elevation, min_area = 25), color = 'imhof3') %>%
  add_overlay(overlayImage, alphalayer = 0.0) %>%
  add_shadow(ray_shade(mapData$elevation, zscale = raster_zscale(rasterObject), maxsearch = 300), 0.5) %>%
  plot_3d(mapData$elevation, 
          zscale = raster_zscale(rasterObject)*1.001, 
          fov = 0, 
          theta = 135, 
          zoom = 0.6, 
          phi = 30, 
          windowsize = c(1000, 1000),
          solid = FALSE,
          shadow = TRUE,
          shadowdepth = -1
  )
render_snapshot()


add_gps_to_rayshader(rasterObject, 
                     lat = trackTable$lat, 
                     lon = trackTable$lon, 
                     alt = trackTable$elevation, 
                     zscale = raster_zscale(rasterObject),
                     alpha = 1
)
```

_______________________________________________________________________________________

# Get track solpe

```{r, results='asis'}
# Retrieve track elevation
trackTable$elev_abs <- extract(rasterObject, TransformCoordinates(trackTable, is.lonLat = T))

# Compute distance between every two points
for (rowId in 2:nrow(trackTable)){
  trackTable[rowId, 'dist_inc'] <- geosphere::distm(trackTable[rowId-1, c('lon', 'lat')],
                                                         trackTable[rowId, c('lon', 'lat')],
                                                         fun = distHaversine
  )
}

# Compute elevation between every two points
trackTable[-1, 'elev_inc'] <- diff(trackTable$elev_abs)

# Replace NA by zeros
trackTable[is.na(trackTable)] <- 0

# Compute cumulative distance
trackTable$dist_cum <- cumsum(trackTable$dist_inc)

# Compute slope
trackTable %<>%
  dplyr::mutate(slope = elev_inc/dist_inc*100)

# Replace NA by zeros
trackTable[is.na(trackTable)] <- 0

# Plot
library(ggplot2)
ggplot(aes(x = dist_cum/1e3, y = slope),data = trackTable) +
  geom_line() + 
  geom_smooth(method = 'loess', span = 0.05, se = F) +
  scale_x_continuous(breaks = scales::pretty_breaks(n = 10)) +
  theme_bw() +
  labs(x = 'km', y = 'slope')

```


# Wikiloc

```{r}
# (worth checking this as well: https://gist.github.com/holstius/6631918 )

pacman::p_load(maptools)

subfolderName <- 'llanes'

# List the kmz files in a given folder path
kmzFileNames <- list.files(here::here('data', 'tracks', subfolderName), pattern = '*.kmz', full.names = FALSE)

# Unzip each KMZ file 
trackList <- lapply(kmzFileNames, 
                 function(x) 
                   maptools::getKMLcoordinates(kmlfile = unzip(zipfile = paste0(here::here('data', 'tracks', subfolderName), '/', x),
                                                               exdir   = here::here('data', 'tracks', 'out')
                   ), 
                   ignoreAltitude = FALSE)
)

# If more than one track was found unbundled in the folder, flatten the list
if (length(trackList) > 1){
  trackList <- unlist(trackList, recursive = FALSE)
}

# Remove odd elements (useless information)
trackList <- trackList[[1]][seq(2, length(trackList[[1]]), 2)]

# Format list elements
trackList <- lapply(trackList, function(x) {
  x <- list(table = data.frame(lon = x[, 1], lat = x[, 2]),
            elevation = x[, 3]
  )
})
```

```{r}
boundingBox <- DefineBoundingBox(trackList = trackList, zoomLevel = 1.1)
```


```{r}
ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackList)
```



# Build track from other tracks and map selections

## Select points

```{r, eval=F}
# Initialize point table
rm(pointTable)

# Select points (close window when finished, the result is in `pointTable`)

SelectPoints(boundingBox, graticuleInterval = 0.05, trackList = trackList)
```

## Build track

Using previously captured points:

```{r, eval=F}
trackTable <- BuildTrack(pointTable, trackList)
```


## Define box from track

```{r, eval=F}
boundingBox <- DefineBoundingBox(pointTable = trackTable, 
                                 boundingBox = NULL, 
                                 p1 = NULL, 
                                 p2 = NULL, 
                                 is.lonLat = T,
                                 zoomLevel = 1.1
)

str(boundingBox)
```

```{r, eval=F}
ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackTable)
```



______________________________________________________________________________________________



# Investigate set of tracks

## Import from wikiloc kmz's

From Google Earth, export as `.kmz` to the folder `'data/tracks/'` the folder with the track (the one that includes both the starting point and the polyline).

```{r}
# (worth checking this as well: https://gist.github.com/holstius/6631918 )

pacman::p_load(maptools)

subfolderName <- 'llanes'

# List the kmz files in a given folder path
kmzFileNames <- list.files(here::here('data', 'tracks', subfolderName), pattern = '*.kmz', full.names = FALSE)

# Unzip each KMZ file 
trackList <- lapply(kmzFileNames, 
                 function(x) 
                   maptools::getKMLcoordinates(kmlfile = unzip(zipfile = paste0(here::here('data', 'tracks', subfolderName), '/', x),
                                                               exdir   = here::here('data', 'tracks', 'out')
                   ), 
                   ignoreAltitude = FALSE)
)

# If more than one track was found unbundled in the folder, flatten the list
if (length(trackList) > 1){
  trackList <- unlist(trackList, recursive = FALSE)
}

# Remove odd elements (useless information)
trackList <- trackList[[1]][seq(2, length(trackList[[1]]), 2)]

# Format list elements
trackList <- lapply(trackList, function(x) {
  x <- list(table = data.frame(lon = x[, 1], lat = x[, 2]),
            elevation = x[, 3]
  )
})
```

## Calculate bbox and show

```{r, eval=F}
boundingBox <- DefineBoundingBox(trackList = trackList, zoomLevel = 1.1)

ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackList)
```

## Get tiles from IGN

```{r, results='asis'}
# Obtain tile codes
tileSet <- FindIGNTiles(boundingBox = boundingBox)

print(tileSet)

# Import data into raster objects
rasterObject <- ImportIGNTiles(tileSet, 
                               tileResolution = 25,
                               folderName = NULL
)

# Crop
rasterObject <- CropRaster(rasterObject, boundingBox)

# Save raster
saveRDS(rasterObject, here::here('output', paste(subfolderName, '.rds', sep = '')))

```


```{r, eval=F}
rasterObject <- readRDS(here::here('output', paste(subfolderName, '.rds', sep = '')))


rm(pointTable)
rm(proposedTrack)

AssesTrackOnMap(trackList = trackList)

ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = proposedTrack)
```


# Export data frame as kml


```{r}
pacman::p_load(psyosphere)

trackName <- 'Llanes_01.kml'

proposedTrack %>% 
  dplyr::select(lon, lat) %>% 
  dplyr::mutate(id = trackName, p_id = 1:nrow(.), time = Sys.Date()) %>% 
  dplyr::mutate(track_name = trackName, 
                file_name = here::here('output',trackName), 
                track_color = '00ff33ff'
  ) %>% 

export_kml(t_id = 'id')
```


# Add computed track to the wikiloc list

```{r}
trackList <- AddTrackToList(trackTable = pointTable, trackList = trackList)

```


________________________________________________________________________________________________

# Scrap Ensidesa's web

```{r}
pacman::p_load(rvest)
pacman::p_load(stringr)

# Loop through all panels
for (pageId in seq(50, 109)){
  ## Build url
  mainUrl <- paste('http://www.gmensidesa.com/PANEL/P',
                                    pageId,
                                    '/P',
                                    pageId, 
                                    '0.HTML',
                                    sep = ''
  )
  
  ## Get main page content
  pageContent <- xml2::read_html(mainUrl)

  ## Get the .zip file url
  zipName <- pageContent %>%
    ### find all links
    html_nodes('a') %>%       
    ### get the url
    html_attr('href') %>%     
    ### find those that end in ZIP
    str_subset('\\.ZIP') %T>% 
    print()
  
  if (length(zipName) != 0){
    ## Download zip
    zipUrl <- paste('http://www.gmensidesa.com/PANEL/P',
                    pageId,
                    '/',
                    zipName,
                    sep = ''
    )
    
    download.file(url = zipUrl, destfile = here::here('output', zipName), mode = 'wb')
    
    ## Unzip
    unzip(zipfile = here::here('output', zipName),
          exdir = here::here('output', 'ensidesa')
    )
  }
}

```



_______________________________________________________________________

# Slope analysis


## Import data from Locus

```{r}
# Unzip kmz into kml
myKml <- unzip(zipfile = here::here('data', 'tracks', 'locus', 'Locus.kmz'),
               exdir = here::here('data', 'tracks', 'out')
)

# Read kml into simple feature object
trackList <- lapply(sf::st_layers(myKml)$name,
                    function(x){
                      sf::st_read(dsn = myKml, layer = x)
                    }
)

# Retrieve track names
trackNames <- lapply(trackList, 
                     function(x){
                       x[[1]][1] %>% as.character() %>% 
                         return()
                     }
)

# Reatain only coordinate/elevation tables
trackList <- lapply(trackList,
                    function(x){
                      x$geometry[[1]][[1]] %>% 
                        return()
                    }
)

# Apply names to list elementes
names(trackList) <- trackNames

# Save
saveRDS(trackList, here::here('output', 'locus.rds'))
```


## Add distance

```{r}
# Load track list
trackList <- readRDS(here::here('output', 'locus.rds'))

# Retain those elements with lonlat information
trackList <- trackList[lengths(trackList) > 1]

trackList <- lapply(trackList, function(x){
  x <- as.data.frame(x) %>% 
    setNames(c('lon', 'lat','altitude'))
  x[1, 'gain'] <- 0
  x[2:nrow(x), 'gain'] <- x[2:nrow(x), 'altitude'] - x[1:(nrow(x)-1), 'altitude']
  x[1, 'distance'] <- 0
  for (rowId in 2:nrow(x)){
    x[rowId, 'distance'] <- geosphere::distm(x[rowId, c('lon', 'lat')], x[rowId-1, c('lon', 'lat')])
  }
  x %<>% dplyr::mutate(slope = gain / distance)
  x[1, 'slope'] <- 0
  
  return(x)
})

# Save
saveRDS(trackList, here::here('output', 'locus_slope.rds'))

```


```{r}
library(myPlotTools)
trackList <- readRDS(here::here('output', 'locus_slope.rds'))

# Filter tracks: get indices
selectedTracks <- c('Pedroso', 'Rueda', 'Pierzu', 'Pienzu', 'Mazuco', 'Ubiña', 'Hoya')

idx <- sapply(selectedTracks, function(x) grepl(x, names(trackList))) %>% 
  rowSums() %>% 
  as.logical()

# Build table
trackTable <- Map(cbind, trackList[idx], trackName = names(trackList)[idx])
trackTable <- lapply(trackTable, function(x) {x$trackName <- as.character(x$trackName); return(x)})
trackTable %<>% dplyr::bind_rows() %>% 
  dplyr::select(slope, trackName) %>% 
  dplyr::filter(slope > 0) %>% 
  dplyr::mutate(slope = atan(slope)*180/pi)

# Plot
data.frame(xAxis = trackTable$trackName, yAxis = trackTable$slope) %>%
  list(boxplot = .) %>%
  PlotFigure(scale.fill.palette = 'white', go.rotate = T, yLabel = 'slope (deg)')


```


# Track analysis



```{r}

containerFolder <- 'luna'

# List the kmz files in a given folder path
kmzFileNames <- list.files(here::here('data', 'tracks', containerFolder), pattern = '*.kmz', full.names = FALSE)

# Unzip each KMZ file 
trackList <- lapply(kmzFileNames, 
                    function(x) 
                      maptools::getKMLcoordinates(kmlfile = unzip(zipfile = paste0(here::here('data', 'tracks', containerFolder), '/', x),
                                                                  exdir = here::here('data', 'tracks', 'out')
                      ), 
                      ignoreAltitude = FALSE)
)

# If more than one track was found unbundled in the folder, flatten the list
if (length(trackList) > 1){
  trackList <- unlist(trackList, recursive = FALSE)
  ## Remove odd elements (useless information)
  trackList <- lapply(trackList, function(x) {if (nrow(x) == 1) {NULL} else {x}})
  trackList[sapply(trackList, is.null)] <- NULL
} else {
  trackList <- unlist(trackList, recursive = FALSE)
  ## Remove odd elements (useless information)
  # trackList <- trackList[[1]][seq(2, length(trackList[[1]]), 2)]
  trackList <- lapply(trackList, function(x) {if (nrow(x) == 1) {NULL} else {x}})
  trackList[sapply(trackList, is.null)] <- NULL
}

# Format list elements
trackList <- lapply(trackList, function(x) {
  x <- list(table = data.frame(lon = x[, 1], lat = x[, 2]),
            elevation = x[, 3]
  )
})

## Calculate bbox and show
boundingBox <- DefineBoundingBox(trackList = trackList, zoomLevel = 1.1)

ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackList)
```


```{r}
myHome <- list(lat = 43.531275, lon = -5.6519543)
myDestination <- list(lat = 43.027526, lon = -5.918700)

mapsapi::mp_directions(
  origin = c(myHome$lat, myHome$lon),
  destination = c(myDestination$lat, myDestination$lon),
  alternatives = TRUE
) %>% 
  mapsapi::mp_get_routes()


```

