---
title: "LabBook"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: myStyle.css
    highlight: haddock
    toc: true
    toc_float: true
    number_sections: false
    code_folding: show
    df_print: paged
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  message = FALSE, # prevents messages that are generated by code from appearing in the finished file
  warning = FALSE, # prevents warnings that are generated by code from appearing in the finished
  error = TRUE, # if FALSE, knitr will not display any error messages generated by the code
  eval = TRUE, # if FALSE, knitr will not run the code in the code chunk
  include = TRUE, # f FALSE, knitr will run the chunk but not include the chunk in the final document
  results = 'hide', # If 'hide', knitr will not display the code's results in the final document. If 'hold', knitr will delay displaying all output pieces until the end of the chunk. If 'asis', knitr will pass through results without reformatting them (useful if results return raw HTML, etc.)
  fig.show = 'asis', # If 'hide', knitr will generate the plots created in the chunk, but not include them in the final document. If 'hold', knitr will delay displaying the plots created by the chunk until the end of the chunk. 
  fig.keep = 'last',
  fig.align = 'center',
  fig.width = 4.5,
  fig.height = 3,
  max.print = 3, # max no. of lines in data frames
  strip.white = TRUE, # remove leading and lagging white lines
  comment = NA # to remove all hashes
  )  
```

# Preliminaries

```{r}
# devtools::install_github('tylermorganwall/rayshader')
pacman::p_load(rayshader)
pacman::p_load(rgdal)
pacman::p_load(proj4)
pacman::p_load(raster)
pacman::p_load(geoviz)
pacman::p_load(shiny)
pacman::p_load(leaflet)
pacman::p_load(geosphere)
pacman::p_load(psyosphere)

sapply(list.files(here::here('R')), function(x) source(here::here('R', x)))

# Gij√≥n
boundingBox <- DefineBoundingBox(p1 = c(lon = -5.75, lat = 43.45), p2 = c(lon = -5.55, lat = 43.6))
ShowOSM(boundingBox = boundingBox)
```


# Import from wikiloc kmz's and define bounding box

From Google Earth, first export as `.kmz` to the folder `'data/tracks/'` the folder with the track (the one that includes both the starting point and the polyline).

```{r}

containerFolder <- 'sanIsidro'

# List the kmz files in a given folder path
kmzFileNames <- list.files(here::here('data', 'tracks', containerFolder), pattern = '*.kmz', full.names = FALSE)

# Unzip each KMZ file 
trackList <- lapply(kmzFileNames, 
                    function(x) 
                      maptools::getKMLcoordinates(kmlfile = unzip(zipfile = paste0(here::here('data', 'tracks', containerFolder), '/', x),
                                                                  exdir = here::here('data', 'tracks', 'out')
                      ), 
                      ignoreAltitude = FALSE)
)

# If more than one track was found unbundled in the folder, flatten the list
if (length(trackList) > 1){
  trackList <- unlist(trackList, recursive = FALSE)
  ## Remove odd elements (useless information)
  trackList <- lapply(trackList, function(x) {if (nrow(x) == 1) {NULL} else {x}})
  trackList[sapply(trackList, is.null)] <- NULL
} else {
  trackList <- unlist(trackList, recursive = FALSE)
  ## Remove odd elements (useless information)
  # trackList <- trackList[[1]][seq(2, length(trackList[[1]]), 2)]
  trackList <- lapply(trackList, function(x) {if (nrow(x) == 1) {NULL} else {x}})
  trackList[sapply(trackList, is.null)] <- NULL
}

# Format list elements
trackList <- lapply(trackList, function(x) {
  x <- list(table = data.frame(lon = x[, 1], lat = x[, 2]),
            elevation = x[, 3]
  )
})

## Calculate bbox and show
boundingBox <- DefineBoundingBox(trackList = trackList, zoomLevel = 1.1)

ShowOSM(boundingBox, graticuleInterval = 0.1, trackList = trackList)
```


# Manually define the bounding box

```{r}
rm(boundingBox)

SelectMapArea()

ShowOSM(boundingBox, graticuleInterval = 0.1)
```


# Get tiles from IGN

## Download

```{r, results='asis'}
# Obtain tile codes
tileSet <- FindIGNTiles(boundingBox = boundingBox) %T>% 
  print()

# Import data into raster objects
rasterObject <- ImportIGNTiles(tileSet, 
                               tileResolution = 25,
                               folderName = NULL
)

# Crop
rasterObject <- CropRaster(rasterObject, boundingBox)

# Save raster
saveRDS(rasterObject, here::here('data', 'tracks', containerFolder, 'rasterObject.rds'))

```

# Pick points of track

```{r, eval=F}
go.usePreviousTrack = FALSE

# Load raster object
rasterObject <- readRDS(here::here('data', 'tracks', containerFolder, 'rasterObject.rds'))
plot(rasterObject)

# Launch shiny app
if (!go.usePreviousTrack){
  rm(pointTable)
  rm(proposedTrack)
}

AssesTrackOnMap(trackList = if (exists('trackList')) {trackList} else {NULL})

# Show result
ShowOSM(boundingBox, graticuleInterval = 1, trackList = proposedTrack)
```


# Export data frame as kml

```{r}
trackName <- 'Obiu.kml'

proposedTrack %>% 
  dplyr::select(lon, lat) %>% 
  dplyr::mutate(id = trackName, p_id = 1:nrow(.), time = Sys.Date()) %>% 
  dplyr::mutate(track_name = trackName, 
                file_name = here::here('output',trackName), 
                track_color = '00ff33ff'
  ) %>% 
export_kml(t_id = 'id')
```

<<<<<<< HEAD

# Add computed track to the wikiloc list

```{r}
trackList <- AddTrackToList(trackTable = pointTable, trackList = trackList)

```


=======
>>>>>>> feature_1
