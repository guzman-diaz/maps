---
title: "Make 3D maps"
date: "`r Sys.Date()`"
output: 
  html_document:
    css: myStyle.css
    highlight: haddock
    toc: true
    toc_float: true
    number_sections: false
    code_folding: show
    df_print: paged
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  cache = TRUE,
  message = FALSE, # prevents messages that are generated by code from appearing in the finished file
  warning = FALSE, # prevents warnings that are generated by code from appearing in the finished
  error = TRUE, # if FALSE, knitr will not display any error messages generated by the code
  eval = TRUE, # if FALSE, knitr will not run the code in the code chunk
  include = TRUE, # f FALSE, knitr will run the chunk but not include the chunk in the final document
  results = 'hide', # If 'hide', knitr will not display the code's results in the final document. If 'hold', knitr will delay displaying all output pieces until the end of the chunk. If 'asis', knitr will pass through results without reformatting them (useful if results return raw HTML, etc.)
  fig.show = 'asis', # If 'hide', knitr will generate the plots created in the chunk, but not include them in the final document. If 'hold', knitr will delay displaying the plots created by the chunk until the end of the chunk. 
  fig.keep = 'last',
  fig.align = 'center',
  fig.width = 4.5,
  fig.height = 3,
  max.print = 3, # max no. of lines in data frames
  strip.white = TRUE, # remove leading and lagging white lines
  comment = NA # to remove all hashes
  )  
```

# Preliminaries

IGN:

http://centrodedescargas.cnig.es/CentroDescargas/catalogo.do?Serie=LIDAR
http://www.ign.es/wcts-app/
https://www.ign.es/iberpix2/visor/


Tutorials:

https://wcmbishop.github.io/rayshader-demo/


```{r}
# devtools::install_github('tylermorganwall/rayshader')
pacman::p_load(rayshader)
pacman::p_load(rgdal)
pacman::p_load(proj4)
pacman::p_load(raster)
pacman::p_load(geoviz)
pacman::p_load(shiny)
pacman::p_load(leaflet)
pacman::p_load(geosphere)


sapply(list.files(here::here('R')), function(x) source(here::here('R', x)))

# Gij√≥n
boundingBox <- DefineBoundingBox(p1 = c(lon = -5.75, lat = 43.45), p2 = c(lon = -5.55, lat = 43.6))
```


# Manually define the bounding box

http://archived.mhermans.net/hiking-gpx-r-leaflet.html


```{r}
rm(boundingBox)

SelectMapArea()

ShowOSM(boundingBox, graticuleInterval = 0.1)
```


## Get tiles from IGN and merge into one single raster object

### Using tiles of high resolution
Regarding `ImportIGNTiles`:

- `tileResolution`: 5 (higher) or 25 (lower) resolution files.

- `folderName`: by default, the folder is `\\pocpaco\maps\`.

The file for resolution 25 of tile 0238 is of the type `PNOA_MDT25_ETRS89_HU30_0238_LID.asc`, downloaded from http://centrodedescargas.cnig.es/CentroDescargas/catalogo.do?Serie=LIDAR.

```{r, results='asis'}
# Obtain tile codes
tileSet <- FindIGNTiles(boundingBox = boundingBox)

print(tileSet)

# Import data into raster objects
rasterObject <- ImportIGNTiles(tileSet, 
                               tileResolution = 25,
                               folderName = NULL
)

# Crop
rasterObject <- CropRaster(rasterObject, boundingBox)

# Save raster
saveRDS(rasterObject, here::here('output', 'rasterObject_AsturiasHD.rds'))

```


## [Alternative] Low resolution map

In case that only Asturias is processed at a 200 resolution:

```{r}
rasterObject <- list()
folderName <- '\\\\pocpaco\\maps\\'

rasterObject[[1]] <- paste(folderName,
                           'PNOA_MDT200_ETRS89_HU30_',
                           'Asturias.asc', 
                           sep = ''
) %>% 
  raster()

rasterObject[[2]] <- paste(folderName,
                           'PNOA_MDT200_ETRS89_HU30_',
                           'Cantabria.asc', 
                           sep = ''
) %>% 
  raster()

rasterObject[[3]] <- paste(folderName,
                           'PNOA_MDT200_ETRS89_HU30_',
                           'Leon.asc', 
                           sep = ''
) %>% 
  raster()

rasterObject[[4]] <- paste(folderName,
                           'PNOA_MDT200_ETRS89_HU30_',
                           'Lugo.asc', 
                           sep = ''
) %>% 
  raster()

rasterObject[[5]] <- paste(folderName,
                           'PNOA_MDT200_ETRS89_HU30_',
                           'Palencia.asc', 
                           sep = ''
) %>% 
  raster()


rasterObject_merge <- do.call(merge, rasterObject)
crs(rasterObject_merge) <- '+proj=utm +zone=30 +north +ellps=WGS84 +datum=WGS84 +units=m +no_defs'

# Crop
rasterObject <- CropRaster(rasterObject_merge, boundingBox) %T>% 
  saveRDS(here::here('output', 'rasterObject_Asturias.rds'))
```






# Crop and mask map

```{r}
rasterObject <- readRDS(here::here('output', 'rasterObject_Asturias.rds'))
```

## Get borders using shape file

```{r}
mapShape <- rgdal::readOGR('\\\\pocpaco\\maps\\shapes\\recintos_autonomicas_inspire_peninbal_etrs89.shp') %>% 
  subset(NAMEUNIT == 'Principado de Asturias') %T>% 
  plot()
```

## Crop

Mask: https://stackoverflow.com/questions/23073669/clipping-raster-using-shapefile-in-r-but-keeping-the-geometry-of-the-shapefile

```{r}
rasterObject_masked <- projectRaster(rasterObject, crs='+proj=longlat +datum=WGS84') %>% 
  raster::crop(extent(mapShape)) %>% 
  raster::mask(mapShape) %T>% 
  plot()

boundingBox <- DefineBoundingBox(is.lonLat = T, 
                  p1 = c(lon = extent(rasterObject_masked)@xmin, lat = extent(rasterObject_masked)@ymin), 
                  p2 = c(lon = extent(rasterObject_masked)@xmax, lat = extent(rasterObject_masked)@ymax)
)


mapData <- ExtractFromRaster(rasterObject_masked)

```


# Get overlay image

Map types are:

- Topo: `'World_Topo_Map'`, `NatGeo_World_Map`, `'esri-topo'`

- Relief: `'apple-iphoto'`, `'World_Street_Map'`, `Ocean_Basemap`

- Picture: `'World_Imagery'`, `'bing'`, `'maptoolkit-topo'`

- Names: `'osm'`, `'opencyclemap'`, `'landscape'`


```{r}
overlayImage <- GetMapImage(boundingBox,
                            mapType = 'osm',
                            imageWidth = dim(mapData$elevation)[1],
                            imageHeight = round(dim(mapData$elevation)[2]),
                            imageFileName = here::here('figs', 'overlay.png')
)



grid::grid.raster(overlayImage)

```















# Plot

Plot result 2D:

```{r}

# Apply 2D overlay
mapData$elevation %>%
  sphere_shade(sunangle = 270,
               texture = 'imhof4'
  ) %>%
  add_overlay(overlayImage, alphalayer = 0.5) %>%
  plot_map()
```

Plot result 3D:

```{r}
# Apply 3D overlay
mapData$elevation %>%
  sphere_shade(texture = 'imhof4', sunangle = 120) %>%
  add_overlay(overlayImage, alphalayer = 0.5) %>%
  add_shadow(ray_shade(mapData$elevation, zscale = raster_zscale(rasterObject), maxsearch = 300), 0.5) %>%
  plot_3d(mapData$elevation, 
          zscale = raster_zscale(rasterObject)*0.2, 
          fov = 0, 
          theta = 15, 
          zoom = 0.6, 
          phi = 60, 
          windowsize = c(1000, 1000),
          solid = FALSE,
          shadow = TRUE,
          shadowdepth = -1
  )
render_snapshot()


# render_highquality(samples=200, scale_text_size = 24,clear=TRUE)

```

```{r}
mapData$elevation %>%
  sphere_shade(texture = "desert") %>%
  # height_shade(texture = topo.colors(256)) %>% 
  add_shadow(ray_shade(mapData$elevation, zscale = 3), 0.5) %>%
  add_shadow(ambient_shade(mapData$elevation), 0) %>%
  # add_overlay(overlayImage, alphalayer = 0.5) %>%
  height_shade(texture = rainbow(256)) %>%
  plot_3d(mapData$elevation, zscale = 1, fov = 0, theta = 200, zoom = 0.5, phi = 88, windowsize = c(1000, 700))
Sys.sleep(0.2)
render_snapshot()
```

```{r}
montereybay <- mapData$elevation

montereybay %>% 
  sphere_shade(texture="desert") %>%
  plot_3d(montereybay, zscale = 40, zoom = 0.4, theta = 215, phi = 35)
render_snapshot(clear = TRUE)
```















_____________________________________


```{r}
folderName <- '\\\\pocpaco\\maps\\'

rasterObject <- raster::raster(paste(folderName, 'overlays', 'Asturias_georef.tif', sep = '\\'))

```

```{r}
rasterObject_masked <- projectRaster(rasterObject, crs='+proj=longlat +datum=WGS84') %>% 
  raster::crop(extent(mapShape)) %>% 
  raster::mask(mapShape) %T>% 
  plot()

```

```{r}
projectRaster(rasterObject, crs='+proj=longlat +datum=WGS84') %>% 
  plot()
```







```{r}
folderName <- '\\\\pocpaco\\maps\\'

library(raster)
library(rayshader)

#Load QGIS georeference image (see https://www.qgistutorials.com/en/docs/3/georeferencing_basics.html)
overlayImage <- raster::stack(paste(folderName, 'overlays', 'Asturias_georef.tif', sep = '\\'))

boundingBox <- overlayImage %>% raster::extent()
```


```{r}
#Set bounding box for final map (cut off edges without data, introduced via reprojection)
# boundingBox = raster::extent(c(68,92,1,20))
boundingBox <- raster::extent(c(-7.22, -4.42, 42.84, 43.70))
# overlayImage <- raster::crop(overlayImage, boundingBox)

#Convert to RGB array
overlayImage_array <- as.array(overlayImage)

#Load elevation data, sourced from GEBCO
rasterObject <- readRDS(here::here('output', 'rasterObject_Asturias.rds'))
# raster1 = raster::raster("gebco_2020_n20.0_s1.0_w68.0_e92.0.tif")

#Reproject and crop elevation data to historical map coordinate system
rasterObject_reprojected <- raster::projectRaster(rasterObject, crs = raster::crs(overlayImage))
rasterObject_reprojected_cropped <- raster::crop(rasterObject_reprojected, boundingBox)

#Reduce the size of the elevation data, for speed
rasterObject_reduced <- rayshader::resize_matrix(as.matrix(rasterObject_reprojected_cropped), scale = 0.2)
rasterObject_reduced <- rasterObject_reprojected_cropped

#Remove bathymetry data
rasterObject_water <- rasterObject_reduced
rasterObject_water[is.na(rasterObject_water)] <- 0
rasterObject_water[rasterObject_water < 0] <- 0
rasterObject_water <- t(rasterObject_water)

#Compute shadows
ambient_layer <- ambient_shade(rasterObject_water, zscale = 10, multicore = TRUE, maxsearch = 200)
ray_layer = ray_shade(rasterObject_water, zscale = 20, multicore = TRUE)

#Plot in 3D
(overlayImage_array/255) %>%
  add_shadow(ray_layer,0.3) %>%
  add_shadow(ambient_layer,0) %>%
  plot_3d(rasterObject_water,zscale=130)

#Render snapshot with depth of field
render_depth(focus=0.982,focallength = 4000)

#Plot in 2D
(overlayImage_array/255) %>%
  add_shadow(ray_layer,0.3) %>%
  add_shadow(ambient_layer,0) %>%
  plot_map()
```

